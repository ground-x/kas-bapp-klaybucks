package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/klaytn/klaytn/accounts/abi"
	"github.com/klaytn/klaytn/common"
	"github.com/klaytn/klaytn/common/hexutil"
	"reflect"
	"strconv"
	"testing"
)



func TestGenStoreContractDeployCode(t *testing.T) {
	storeName := "klaybuck 1st store"

	address := "0x467355508b0b6138da457015dca1bb696fedf062"
	// code := GenStoreContractDeployCode(storeName, address)

	abi , err := abi.JSON(bytes.NewBufferString(storeContractABI))
	if err != nil {
		t.Fatal(err)
	}


	ret, err := abi.Constructor.Inputs.Pack(storeName, common.HexToAddress(address))
	if err != nil {
		t.Fatal(err)
	}

	fmt.Println(Encode(ret))
	// fmt.Println(code)
}

func TestUnpackStructArray(t *testing.T){
	target := "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000026aca7db482382c7b32a1437c6b95cbcd14378ab0000000000000000000000004dd47eea9581a9f19a2019990b498473b64ee277000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000096b6c61796275636b73000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000103132372e30363237333535313236303600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001033372e3530373634383136333430353300000000000000000000000000000000"
	_abi , err := abi.JSON(bytes.NewBufferString(storeListContractABI))
	if err != nil {
		t.Fatal(err)
		return
	}

	// "outputs": [{"components": [{"name": "name","type": "string"},{"name": "locationX","type": "string"},
	// {"name": "locationY","type": "string"},{"name": "storeOwner","type": "address"},{"name": "storeContract","type": "address"},{"name": "status","type": "uint8"}],"name": "","type": "tuple[]"}]
	var arr []StoreInfoArray
	if err := _abi.Unpack(&arr, "getStores", hexutil.MustDecode(target)); err != nil {
		t.Fatal(err)
		return
	}

	ret, err := json.Marshal(arr)
	if err != nil {
		t.Fatal(err)
	}
	fmt.Println(string(ret))
}

func TestParseLogs(t *testing.T){
	logs := "0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000001944000000000000000000000000000000000000000000000000000000000000001454323738383139323931353238373638383036380000000000000000000000000000000000000000000000000000000000000000000000000000000000000047302535426e616d652535443d616d65726926302535427175616e746974792535443d3226312535426e616d652535443d6c6174746526312535427175616e746974792535443d3100000000000000000000000000000000000000000000000000"
	topics := []string{"0x6f92fa64de3d4bdc56150e4aef5d889e888bb19b79f50beb78f5777ac7e20161","0x000000000000000000000000000000000000000000000000000000000000000b","0x000000000000000000000000d6c635b1504dc4ba3cf0cd8ebdb61923f0e2bdaa"}

	_abi , err := abi.JSON(bytes.NewBufferString(storeContractABI))
	if err != nil {
		t.Fatal(err)
	}

	var receipt OrderReceipt
	if err := _abi.Events["OrderReciept"].Inputs.Unpack(&receipt,hexutil.MustDecode(logs)); err != nil {
		t.Fatal(err)
	}

	receipt.From = common.HexToAddress(topics[2])
	index, err := strconv.ParseUint(topics[1][24:], 16, 64)
	if err != nil {
		t.Fatal(err)
		return
	}

	receipt.Index = uint32(index)
	t.Log(receipt)
}

func TestParseLogsResult(t *testing.T){
	var logJson RPCReturnInterface
	result :=`{"jsonrpc":"2.0","id":1,"result":[{"address":"0x3810365138fb646e8cb01787aa31110ed222da21","topics":["0x6f92fa64de3d4bdc56150e4aef5d889e888bb19b79f50beb78f5777ac7e20161","0x000000000000000000000000000000000000000000000000000000000000000b","0x000000000000000000000000d6c635b1504dc4ba3cf0cd8ebdb61923f0e2bdaa"],"data":"0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000001944000000000000000000000000000000000000000000000000000000000000001454323738383139323931353238373638383036380000000000000000000000000000000000000000000000000000000000000000000000000000000000000047302535426e616d652535443d616d65726926302535427175616e746974792535443d3226312535426e616d652535443d6c6174746526312535427175616e746974792535443d3100000000000000000000000000000000000000000000000000","blockNumber":"0x20afb3e","transactionHash":"0x6a40e46f41b2c6459abc482f114cd225e7889ad227823f81a41de49e1ce4b93b","transactionIndex":"0x0","blockHash":"0x8637ed2ddc46ec3f4b6b4cadaa8e81e3df7ca37b74af6c7363f3b2b25b37f9de","logIndex":"0x0","removed":false}]}`

	if err := json.Unmarshal([]byte(result), &logJson); err != nil {
		t.Fatal(err)
	}

	retInterface, ok := logJson.Result.([]interface{})
	if !ok {
		t.Fatal("conversion failure")
	}

	retInterface0, ok := retInterface[0].(map[string]interface{})
	if !ok {
		t.Fatal("conversion failure 2")
	}

	// t.Log(retInterface0["topics"])
	// t.Log(retInterface0["data"])

	topics := retInterface0["topics"].([]interface{})

	t.Log(reflect.TypeOf(topics))
	t.Log(topics[0].(string))
}